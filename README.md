# Linux

## Основы Linux

### Введение в Linux

Что такое Linux?<br>
**Linux** - это семейство Unix-подобных операционных систем, построенных на базе ядра Linux. **Дистрибутивы Linux** - это операционные системы, которые включают в себя ядро Linux и набор других программ, таких как оболочки, компиляторы и драйверы. Linux системы распространяются в основном бесплатно в виде различных дистрибутивов в форме, готовой для установки и удобной для сопровождения и обновлени.<br>
<br>
Основные компоненты Linux:<br>
- Загрузчик: Программное обеспечение, управляющее процессом загрузки компьютера1.
- Ядро: Сердце системы, управляющее всеми компонентами ОС и компьютера1.
- Демоны: Служебные программы, работающие в фоновом режиме1.
- Система инициализации: Подсистема, управляющая учетной записью пользователя и демонами1.
- Графический сервер: Подсистема, управляющая отображением графической информации на мониторе1.
- Среда рабочего стола: Пользовательский интерфейс1.
- Приложения: Пользовательские программы, выполняющие различные функции1.<br>

Первый вход в систему. Знакомство с терминалом.<br><br>
Вот несколько простых команд, с которых можно начать знакомство с терминалом:<br>
```pwd``` (print working directory): Показывает текущий каталог.  
```date:``` Показывает текущую дату и время.  
```cal:``` Показывает календарь на текущий месяц.  
```uname -a:``` Показывает информацию о системе.  
```exit:``` Выход из терминала.  
```cd``` Сменить текущий каталог  
```ls``` Показать содержимое каталога  
```mkdir <имя_каталога>``` Создать каталог  
```rmdir <имя_каталога>``` Удалить пустой каталог  
```touch <имя_файла>``` Создать пустой файл<br><br>
Создать структуру каталогов для проектов.<br>
```mkdir ~/projects```<br>
```mkdir ~/projects/web_apps ~/projects/scripts ~/projects/databases ~/projects/documentation```<br>
```mkdir ~/projects/web_apps/frontend ~/projects/web_apps/backend```<br>
```mkdir ~/projects/scripts/bash ~/projects/scripts/python```<br>
```mkdir ~/projects/databases/mysql ~/projects/databases/postgresql```<br>
Проверить созданые каталоги<br>
```tree ~/projects```<br>
### Работа с файлами и текстом

Работа с файлами: cp, mv, rm, cat, less, head, tail.<br>
```cp <источник> <назначение>``` Копирование файла<br>
```mv <источник> <назначение>``` Перемещение файла<br>
```rm <имя_файла>``` Удаление файла<br>
```cat <имя_файла>``` Просмотр содержимого файла<br>
```less <имя_файла>``` Просмотр содержимого постранично<br>
```head <имя_файла>``` Просмотр первых строк файла<br>
```tail <имя_файла>``` Просмотр послдних строк файла<br><br>

Редактирование текстовых файлов: nano, vim (основы).<br>
**Nano** – это простой и удобный текстовый редактор, который часто
 предустановлен в большинстве дистрибутивов Linux.
```nano <имя_файла>```<br>
**Vim** – это мощный и гибкий текстовый редактор, который требует 
больше времени на освоение, но предоставляет гораздо больше возможностей<br>
```vim <имя_файла>```


Режимы работы:<br>
- Командный режим: Используется для навигации по файлу, выполнения команд и 
переключения между режимами. После запуска vim находится в командном режиме.
- Режим вставки: Используется для ввода и редактирования текста. Для перехода в 
режим вставки нажмите клавишу i (insert). Для возврата в командный режим нажмите клавишу Esc.
- Режим последней строки: Находясь в командном режиме, можно выполнять сложные операции 
редактирования текста с помощью клавиши : (двоеточие). 
При нажатии этой клавиши курсор устанавливается в последнюю строку экрана.

Основные команды (в командном режиме):<br>
`:w`: Сохранить файл.  
`:q`: Выйти из редактора.  
`:q!`: Выйти без сохранения изменений.  
`:wq`: Сохранить и выйти.  
`i`: Перейти в режим вставки текста слева от курсора.  
`a`: Перейти в режим вставки текста справа от курсора3.  
`Esc`: Вернуться в командный режим.  
`/`: Поиск текста (введите текст для поиска и нажмите Enter). 
Для перехода к следующему результату поиска нажмите n, для перехода к предыдущему – N.  
`dd`: Удалить строку.  
`yy`: Копировать строку.  
`p`: Вставить строку.  
`u`: Отменить последнее действие3.  
`Ctrl+r`: Повторить отмененное действие3.


#### Перенаправление ввода/вывода: >, >>, |.<br>
В Linux, перенаправление ввода/вывода — это мощный механизм, позволяющий управлять потоками 
данных между командами и файлами. Любая Linux-утилита принимает входные данные и выдает 
выходные данные. Эти данные передаются через три стандартных потока:<br>
- stdin (стандартный ввод, дескриптор 0): По умолчанию, ввод осуществляется с клавиатуры.  
- stdout (стандартный вывод, дескриптор 1): По умолчанию, вывод отображается на экране.  
- stderr (стандартный вывод ошибок, дескриптор 2): По умолчанию, сообщения об ошибках также отображаются на экране.  


Перенаправление позволяет изменить источник ввода или место назначения вывода.

```1. > (Перенаправление вывода)```

Оператор > перенаправляет стандартный вывод команды в файл. Если файл существует, он будет перезаписан.<br>
```command > file.txt```<br>
```ls -l > files.txt```

```2. >> (Добавление вывода)```

Оператор >> перенаправляет стандартный вывод команды в файл, добавляя его в конец файла. Если файл не существует, он будет создан.
```command >> file.txt```<br>
```echo "Hello, world!" >> log.txt```

```3. | (Конвейер)```

Оператор | (pipe) перенаправляет стандартный вывод одной команды на стандартный ввод другой команды. 
Это позволяет объединять несколько команд в цепочку для выполнения сложных задач.<br>
```command1 | command2 | command3```<br>
```cat file.txt | grep "keyword" | less```

Для перенаправления стандартного потока ошибок используется оператор ```2>```.
```command 2> error.log```

Объединение стандартного вывода и стандартного потока ошибок<br>
Можно перенаправить как стандартный вывод, так и стандартный поток ошибок в один файл.<br>
```command &> file.txt```

Перенаправление стандартного ввода (stdin)<br>
Оператор < перенаправляет содержимое файла на стандартный ввод команды.<br>
```command < file.txt```<br>
```sort < list.txt```

Поиск файлов: find, locate.<br>
```find [путь] [параметры] [выражение]```
```locate <имя_файла>```

Пример

```find /home/user -name myfile.txt```
```find /home/user -type f```
```find /home/user -size +10M```
```find /home/user -mtime -7```
```find . -type f -user John```
```find . -perm 777```
```find . -maxdepth 1 -type f -name "*.txt"```
```locate myfile```

- ```-name```: Поиск файлов по имени (с учетом регистра)
- ```-iname```: Поиск файлов по имени без учета регистра
- ```-type```: Поиск файлов определенного типа
  - ```f```: Обычный файл
  - ```d```: Каталог
- ```-size```: Поиск файлов по размеру
- ```-mtime```: Поиск файлов по времени последней модификации (в днях)
- ```-user```: Поиск файлов, принадлежащих определенному пользователю
- ```-perm```: Поиск файлов по разрешению и режиму доступа
- ```-maxdepth```: Ограничение глубины поиска

### Пользователи и права доступа

Пользователи и группы: useradd, userdel, groupadd, groupdel.

Создание нового пользователя.<br>
```sudo useradd [опции] <имя_пользователя>```

- ```-m```: Создать домашний каталог для пользователя (по умолчанию домашний каталог не создается).
- ```-d <путь>```: Указать путь к домашнему каталогу пользователя.
- ```-g <имя_группы>```: Указать основную группу пользователя.
- ```-G <список_групп>```: Указать список дополнительных групп, в которые будет добавлен пользователь (группы разделяются запятыми).
- ```-s <оболочка>```: Указать оболочку (shell) пользователя (например, /bin/bash, /bin/sh, /bin/zsh).
- ```-c <комментарий>```: Добавить комментарий о пользователе.
- ```-u <UID>```: Задать User ID (пользователя).

Пример

```sudo useradd -m -d /home/newuser -s /bin/bash newuser```: Создать пользователя newuser с домашним каталогом /home/newuser и оболочкой /bin/bash.  
```sudo useradd -m -g users -G wheel,audio testuser```: Создать пользователя testuser, добавить его в группы users, wheel и audio.

Удаление пользователя.<br>
```sudo userdel [опции] <имя_пользователя>```

- ```-r```: Удалить домашний каталог пользователя и его содержимое.
- ```-f```: Принудительное удаление пользователя.

Пример

```sudo userdel testuser```: Удалить пользователя testuser, но оставить его домашний каталог.  
```sudo userdel -r testuser```: Удалить пользователя testuser вместе с его домашним каталогом и содержимым

Создание новой группы.<br>
```sudo groupadd [опции] <имя_группы>```

- ```-g <GID>```: Указать Group ID (группы).
- ```-r```: Создать системную группу.

Пример

```sudo groupadd developers```: Создать группу с именем developers.  

Удаление группы.<br>
```sudo groupdel <имя_группы>```

- ```-f```: Принудительное удаление группы.

Пример

```sudo groupdel developers```: Удалить группу с именем developers.  

Дополнительные команды:<br>
- ```-usermod```: Изменение параметров существующего пользователя.
- ```-passwd```: Изменение пароля пользователя.
- ```-groups```: Показать, в каких группах состоит пользователь.  
Управление членством в группах:<br>
- ```gpasswd -a <имя_пользователя> <имя_группы>```: Добавить пользователя в группу
- ```gpasswd -d <имя_пользователя> <имя_группы>```: Удалить пользователя из группы
- ```usermod -G <список_групп> <имя_пользователя>```:  Изменить список дополнительных групп, в которых состоит пользователь. Важно: при использовании этой команды необходимо указать все группы, в которых должен состоять пользователь, иначе он будет удален из остальных групп

Права доступа: chmod, chown, chgrp.<br>
```rwxr-xr-x, где:```  
- Первые три символа — права владельца (Owner).
  - Чтение (r), Запись (w), Выполнение (x)
- Следующие три — права группы (Group).  
- Последние три — права остальных пользователей (Others).

Для изменения прав доступа к файлам и каталогам. Символьная нотация:<br>
```chmod [опции] <права> <файл>```

```chmod u+x script.sh```  # Добавить право выполнения для владельца
```chmod g-w file.txt```   # Удалить право записи для группы
```chmod o=r file.txt```   # Установить только право чтения для остальных

- ```u```: владелец
- ```g```: группа
- ```o```: остальные
- ```a```: все пользователи
- ```+```: добавить право
- ```-```: удалить право
- ```=```: установить конкретные права

Для изменения прав доступа к файлам и каталогам. Числовая нотация:<br>
Чтение (r) = 4, Запись (w) = 2, Выполнение (x) = 1

```chmod 755 script.sh```  # rwxr-xr-x (владелец имеет все права, группа и остальные имеют право чтения и выполнения)
```chmod 644 file.txt```   # rw-r--r-- (владелец имеет право записи и чтения, группа и остальные имеют только чтение)

Для изменения владельца и группы файла или каталога.<br>
```sudo chown [новый_владелец][:новая_группа] <файл>```

```sudo chown user1 file.txt``` # Изменить владельца на user1
```sudo chown user1:group1 file.txt```   # Изменить владельца на user1 и группу на group1

Для изменения группы файла или каталога.<br>
```sudo chgrp <новая_группа> <файл>```

```sudo chgrp group1 file.txt```   # Изменить группу файла на group1
```chmod 700 myscript.sh```   # Владелец имеет все права, группа и остальные не имеют прав.
```sudo chown alice report.txt```   # Изменить владельца файла report.txt на пользователя alice.
```sudo chgrp developers project.txt```   # Изменить группу файла project.txt на developers.

Специальные разрешения: SUID, SGID, Sticky Bit.<br>
**SUID** - 4 (Set User ID) - Применяется к исполняемым файлам. Если файл имеет флаг SUID, то при его выполнении процесс получает права владельца файла, а не пользователя, который запускает файл. Буква s вместо x в правах владельца (rws)<br>
--- Установка: ```chmod u+s <файл>```
--- Удаление: ```chmod u-s <файл>```
--- Числовой пример: ```chmod 4755 myfile```<br>
**SGID** - 2 (Set Group ID) - Применяется как к файлам так и к каталогам. Процесс запущенный с этим файлом получаетп рава группы файлов. Буква s вместо x в правах группы (rwxr-s).<br>
--- Установка: ```chmod g+s <файл или каталог>```
--- Удаление: ```chmod g-s <файл или каталог>```
--- Числовой пример: ```chmod 2755 mydir```<br>
**Sticky Bit** - 1 - Применяется только к каталогам. Если каталог имеет Sticky Bit, то удалять или изменять файлы внутри него может только владелец файла или суперпользователь (даже если у других пользователей есть права записи на каталог). Буква t вместо x в правах остальных (rwxrwxrwt).<br>
--- Установка: ```chmod +t <каталог>```
--- Удаление: ```chmod -t <каталог>```
--- Числовой пример: ```chmod 1777 /tmp```<br>

```-rwsr-xr-x``` ```-rwxr-sr-x``` ```drwxrwxrwt```<br>

### Пакетный менеджер

Пакетный менеджер: yum (CentOS) / apt (Ubuntu).<br>
```yum``` (**Yellowdog Updater, Modified**) — это менеджер пакетов, используемый в дистрибутивах на базе RPM, таких как CentOS и Red Hat Enterprise Linux.<br>
```sudo yum install <имя_пакета>``` - Установка пакета<br>
```sudo yum update <имя_пакета>``` - Обновление конкретного пакета<br>
```sudo yum remove <имя_пакета>``` - Удаление пакета<br>
```yum search <имя_пакета>``` - Поиск пакета<br>
```yum list all``` - Список всех доступных пакетов<br>
```yum help``` - Справка по командам<br>
```apt``` (**Advanced Package Tool**) — это менеджер пакетов, используемый в дистрибутивах на базе Debian, таких как Ubuntu.<br>
```sudo apt install <имя_пакета>``` - Установка пакета<br>
```sudo apt update <имя_пакета>``` - Обновление конкретного пакета<br>
```sudo apt upgrade``` - Обновление всех пакетов<br>
```sudo apt remove <имя_пакета>``` - Удаление пакета<br>
```apt search <имя_пакета>``` - Поиск пакета<br>
```sudo apt purge <имя_пакета>``` - Удаление пакета и его конфигурационных файлов<br>
```apt list --installed``` - Список всех установленных пакетов<br>

Работа с репозиториями.<br>
**Репозитории** — это хранилища программного обеспечения, которые содержат пакеты, метаданные и информацию о зависимостях для установки и управления программами на Linux.<br>
Добавление репозиториев. Удаление репозиториев.<br>
```sudo apt-key adv --fetch-keys 'https://mariadb.org/mariadb_release_signing_key.asc'```<br>
```sudo add-apt-repository 'deb [arch=amd64,arm64,ppc64el] http://mirror.mephi.ru/mariadb/repo/10.5/ubuntu focal main'```<br>
```sudo add-apt-repository --remove 'deb [arch=amd64,arm64,ppc64el] http://mirror.mephi.ru/mariadb/repo/10.5/ubuntu focal main'```<br>
Добавление PPA-репозитория. Удаление PPA-репозитория.<br>
```sudo add-apt-repository ppa:repository/ppa```<br>
```sudo add-apt-repository --remove ppa:repository/ppa```<br>
После добавления или удаления репозитория необходимо обновить список доступных пакетов.<br>
```sudo apt update```<br>

#### Скрипт, автоматизирующий создание пользователя с заданными параметрами (логин, пароль, группа, домашняя директория) и установку базового набора пакетов.<br>
```chmod +x create_user.sh``` - Права на выполнение<br>
```./create_user.sh myuser mypassword users /home/myuser``` - Запуск скрипта с аргументами<br>
[create_user.sh](https://github.com/AnatolyKuzmin/Linux/blob/main/create_user.sh)<br>
```-m```: Создает домашнюю директорию. 
```-d```: Указывает домашнюю директорию. 
```-g```: Указывает основную группу. 
```-s```: Указывает оболочку.<br>

## Системное администрирование

### Процессы и системные службы

Процессы:
- ```ps [опции]``` - для отображения информации о текущих процессах,
  - `-e` или `-A`: Показать все процессы в системе.
  - `-u`: Показать процессы для указанного пользователя.
  - `-f`: Расширенный формат вывода, показывающий больше информации о процессах.
  - `aux`: Отображает все процессы в системе в расширенном формате.
- ```top [опции]``` - отображает информацию о работающих процессах и используемых ими системных ресурсах в реальном времени,
  - `q`: Выход из top.
  - `k`: Отправить сигнал процессу (запросит PID и номер сигнала).
  - `M`: Сортировка процессов по использованию памяти.
  - `P`: Сортировка процессов по использованию процессора.
  - `u`: Показать процессы для указанного пользователя.
- ```kill [опции] <PID>``` - для отправки сигналов процессам, что позволяет завершить или приостановить их выполнение.
  - `15 (SIGTERM)`: Умное завершение процесса (по умолчанию).
  - `9 (SIGKILL)`: Принудительное завершение процесса.
  - `19 (SIGSTOP)`: Приостановка процесса.<br>

Управление процессами: запуск, остановка, перезапуск.<br>
`sudo systemctl start apache2`: Запустить веб-сервер Apache<br>
`sudo systemctl status apache2`: Проверить статус.<br>

`kill <PID>`: Завершить процесс.<br>
`kill -9 <PID>`: Принудительно завершить процесс.<br>
`pkill <name>`: Завершить процесс по имени.<br>

`sudo systemctl restart apache2`: Перезапуск.<br>

`nice -n 10 firefox`: Устанавливает приоритет процесса перед его запуском.<br>
`renice -n 10 -p <PID>`: Изменяет приоритет уже запущенного процесса.<br>

Системные службы: systemctl.<br>
`sudo systemctl start <имя_службы>`: Запуск службы.<br>
`sudo systemctl stop <имя_службы>`: Остановка службы.<br>
`sudo systemctl restart <имя_службы>`: Перезапуск службы.<br>
`sudo systemctl status <имя_службы>`: Проверка статуса службы.<br>
`sudo systemctl enable <имя_службы>`: Включение автозапуска службы.<br>
`sudo systemctl disable <имя_службы>`: Выключение автозапуска службы.<br>
`sudo systemctl reload <имя_службы>`: Перезагрузка конфигурации службы.<br>
`sudo systemctl is-active <имя_службы>`: Проверка активности службы.<br>
`sudo systemctl is-enabled <имя_службы>`: Проверка наличия службы в автозагрузке.<br>
`sudo systemctl mask <имя_службы>`: Маскирование службы.<br>
`sudo systemctl unmask <имя_службы>`: Снятие маски с службы.<br>

### Журналирование и мониторинг<br>
Журналирование: /var/log/.<br>
Журналирование — это процесс записи событий, происходящих в системе.<br>
`journalctl` Просмотр всех логов
`journalctl -u apache2.service` Просмотр логов конкретной службы
`journalctl -f` Просмотр последних записей
`sudo truncate -s 0 /var/log/syslog` Удалить или обнулить файл журнала<br>
Файл журнала	Описание<br>
***/var/log/syslog***	Общий системный журнал. Содержит сообщения от ядра и системных служб (Ubuntu).<br>
***/var/log/messages***	Общий системный журнал (используется в CentOS).<br>
***/var/log/auth.log***	Журнал аутентификации (успешные входы, ошибки входа).<br>
***/var/log/kern.log***	Сообщения ядра Linux.<br>
***/var/log/dmesg***	Сообщения ядра, связанные с загрузкой системы.<br>
***/var/log/boot.log***	Лог загрузки системы.<br>
***/var/log/httpd/***	Логи веб-сервера Apache (если установлен).<br>
***/var/log/nginx/***	Логи веб-сервера Nginx (если установлен).<br>
***/var/log/apt/***	Логи работы пакетного менеджера APT (установка, обновление пакетов).<br>
***/var/log/faillog***	Лог неудачных попыток входа в систему.<br>
***/var/log/wtmp***	Бинарный файл с историей входов и выходов пользователей.<br>

Анализ лог-файлов: grep, awk, sed.<br>
`grep [опции] <ключевое_слово> <файл>` -  для поиска строк, содержащих заданное ключевое слово или регулярное выражение<br>
Опции: `-i` - Игнорировать регистр, `-v` - Вывести строки, которые не содержат ключевое слово, `-n` - Показать номер строки, `-r` - Рекурсивный поиск в каталоге.<br>
`awk '<выражение>' <файл>` -  для обработки текстовых данных, который позволяет извлекать определенные поля из строк.<br>
Пример `awk '/error/ {print $1, $2, $0}' /var/log/syslog` Найти строки, содержащие "error", и вывести только дату, время и сообщение.<br>
`sed '<выражение>' <файл>` -  потоковый редактор, который позволяет выполнять поиск и замену текста.<br>
Пример `sed 's/error/ERROR/g' /var/log/syslog` Заменить слово "error" на "ERROR" в файле /var/log/syslog, `sed '/debug/d' /var/log/syslog` Удалить все строки, содержащие "debug".<br>

Мониторинг системы: vmstat, iostat, df, du.<br>
`vmstat [интервал] [количество]` -  (Virtual Memory Statistics) предоставляет информацию о производительности системы, включая использование процессора, памяти, ввода-вывода и свопа.<br>
`iostat [опции] [интервал] [количество]` -  (Input/Output Statistics) используется для мониторинга производительности ввода-вывода и загрузки процессора.<br>
`df [опции]` -  (Disk Free) отображает информацию о свободном и занятом дисковом пространстве для файловых систем.<br>
Опции: `-h` - Отображение в удобном для чтения формате (например, MB/GB), `-T` - Показать тип файловой системы, `--total` - Показать итоговое использование.<br>
`du [опции] [путь]` -  (Disk Usage) используется для отображения объема занятого дискового пространства файлами и каталогами.<br>
Опции: `-h` - Удобный для чтения формат, `-s` -  Вывести только общий размер указанного каталога, `--max-depth=N` - Ограничить глубину анализа до N уровней.<br>

Настройка ротации логов: logrotate.<br>
**logrotate** — это утилита для автоматического управления лог-файлами. Она позволяет: Архивировать старые логи, Удалять устаревшие логи,
 Сжимать логи (например, в формат .gz), Настраивать ротацию по времени (ежедневно, еженедельно) или по размеру файла.<br>
***/etc/logrotate.conf*** - файл задает общие параметры для всех логов. ***/etc/logrotate.d/*** - в этом каталоге хранятся отдельные конфигурационные файлы для разных приложений (например, apache2, nginx, mysql).<br>
**Пример базовой конфигурации для ротации логов**  
```
text
/var/log/example.log {
    daily                # Ротация ежедневно
    rotate 7             # Хранить 7 архивов
    compress             # Сжимать архивы (gzip)
    delaycompress        # Сжимать архивы через ротацию
    missingok            # Игнорировать ошибки, если файл отсутствует
    notifempty           # Не ротировать пустые файлы
    create 0640 root root # Создавать новый файл с указанными правами и владельцем
    postrotate           # Команды для выполнения после ротации
        systemctl reload example-service
    endscript
}
```
<br>

[Скрипт](https://github.com/AnatolyKuzmin/Linux/blob/main/log_error_notifier.sh), который анализирует лог-файл и отправляет уведомление, если обнаружена ошибка.<br>
Скрипт проверяет, был ли передан путь к лог-файлу. Если нет, выводится сообщение об использовании.<br>
`chmod +x log_error_notifier.sh ` Сделайте его исполняемым, `./log_error_notifier.sh /var/log/syslog` Запустить скрипт, указав путь к лог-файлу<br>

### Сеть
Настройка сети: ip, ifconfig.<br>
**ifconfig** — это классическая команда для управления сетевыми интерфейсами в Linux.  
`ifconfig` Отображение информации о сетевых интерфейсах, `sudo ifconfig eth0 192.168.0.10 netmask 255.255.255.0` Установка IP-адреса, `sudo ifconfig eth0 up` `sudo ifconfig eth0 up` Включение/отключение интерфейса.  
Примеры  
`sudo ifconfig eth0 netmask 255.255.255.224` Назначение маски сети  
`sudo ifconfig eth0 broadcast 172.16.25.63` Назначение широковещательного адреса  
**ip** — это более современная и мощная альтернатива ifconfig  
`ip addr show` Отображение информации о сетевых интерфейсах, `sudo ip addr add 192.168.0.10/24 dev eth0` Установка IP-адреса, `sudo ip addr del 192.168.0.10/24 dev eth0` Удаление IP-адреса, `sudo ip link set eth0 up` `sudo ip link set eth0 down` Включение/отключение интерфейса  
Примеры  
`sudo ip route add default via 192.168.0.1 dev eth0` Добавление маршрута  
`ip route show` Просмотр таблицы маршрутов  

Файлы конфигурации сети.<br>
`/etc/hosts` файл содержитсопоставление имен хостов  
`/etc/hostname` cодержит имя хоста системы, которое устанавливается при загрузке  
`/etc/resolv.conf` определяет DNS-серверы, используемые для разрешения имен хостов  
`/etc/netplan/` для конфигурации сети. Файлы конфигурации находятся в этом каталоге  
`/etc/hosts.allow` и `/etc/hosts.deny` для управления доступом к сетевым службам на основе IP-адресов или имен хостов  

Диагностика сети: ping, traceroute, netstat, ss.<br>
`ping [опции] <адрес_хоста>` — это простейший инструмент для проверки сетевого подключения  
`traceroute [опции] <адрес_хоста>` - показывает маршрут следования пакетов до целевого хоста. Это помогает выявить проблемы в сети  
`netstat [опции]` — это утилита для отображения информации о сетевых соединениях, таблице маршрутизации и статистике сетевых протоколов  
- `netstat -a` Просмотр всех сетевых соединений  
- `netstat -at` Просмотр только TCP-соединений
- `netstat -r` Просмотр таблицы маршрутизации
`ss [опции]` — это современная альтернатива netstat. Она показывает информацию о сетевых сокетах
- `ss -a` Просмотр всех сетевых соединений
- `ss -t` Просмотр только TCP-соединений
- `ss -l` Просмотр только прослушиваемых портов

DNS: nslookup, dig.<br>
`nslookup [опции] <домен>` — это классический инструмент для запроса DNS-серверов и получения информации о доменах.  
`dig [опции] <домен>` — это более современная и гибкая альтернатива nslookup. Она предоставляет более подробную информацию о DNS-записях.  
Основные DNS-записи:  
- A-записи: Связывают доменное имя с IP-адресом.  
- MX-записи: Определяют серверы для приема почты.
- NS-записи: Указывают на DNS-серверы, обслуживающие домен.
- PTR-записи: Связывают IP-адрес с доменным именем (обратное разрешение).
Примеры  
`dig google.com` Проверка A-записи домена 
`dig mx example.com` Проверка MX-записей домена
`dig ns example.com` Проверка NS-записей домена 
`dig google.com @8.8.8.8` Использование другого DNS-сервера 

### SSH

SSH: подключение к удаленным серверам.<br>
это протокол, для обеспечения безопасного удаленного управления серверами.  
`sudo apt install openssh-server` - Установка OpenSSH-сервера  
`sudo systemctl start sshd` - Запуск SSH-сервера  
`sudo systemctl enable sshd` - Включение автозапуска SSH-сервера  
Примеры  
`ssh user@192.168.1.100` Подключение с указанием имени пользователя  
`ssh -p 2222 user@192.168.1.100` Подключение с использованием нестандартного порта  
`scp local_file user@remote_host:/remote/directory` Копирование файла на удаленный сервер  
`dscp user@remote_host:/remote/file local_directory` Копирование файла с удаленного сервера  
`ssh-keygen` Генерация ключей  
`ssh-copy-id user@remote_host` Копирование публичного ключа на сервер  

Аутентификация по паролю и по ключу.<br>
Аутентификация по паролю — это простейший метод, при котором для доступа к серверу требуется вводить имя пользователя и пароль.  
`ssh user@server_address`  
Аутентификация по ключу использует пару ключей: открытый и закрытый. Открытый ключ копируется на сервер, а закрытый ключ остается на клиенте.  
`ssh user@server_address`  

Настройка SSH-сервера.<br>
Установка OpenSSH-сервера: `sudo apt update` Обновите репозиторий, `sudo apt install openssh-server` Установите OpenSSH-сервер, `sudo systemctl enable sshd` Проверьте статус SSH-сервера.  
Настройка SSH-сервера: `sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup` Создайте резервную копию конфигурационного файла, `sudo nano /etc/ssh/sshd_config` Откройте конфигурационный файл, `Port 2222` Измените порт, `sudo systemctl restart sshd` Перезапустите SSH-сервер.  

SSH-туннелирование.<br>
технология, позволяющая создавать защищенные каналы связи между клиентом и сервером. SSH-туннелирование устанавливает зашифрованное соединение между локальным хостом и удаленным сервером. Это позволяет безопасно передавать TCP-пакеты и обеспечивает конфиденциальность данных.  
Типы SSH-туннелей:
1. Прямой туннель (Local Port Forwarding) - Перенаправляет трафик с локального порта на удаленный сервер. `ssh -L 8080:localhost:80 user@remote_server` Доступ к веб-серверу на удаленном сервере через локальный порт.
2. Обратный туннель (Remote Port Forwarding) - Перенаправляет трафик с удаленного порта на локальный хост. `ssh -R 8080:localhost:80 user@remote_server` Доступ к локальному веб-серверу из внешней сети через удаленный сервер.
3. Динамический туннель (Dynamic Port Forwarding) - Создает SOCKS-прокси, позволяя обходить ограничения и анонимизировать трафик. `ssh -D 8080 user@remote_server` Создание SOCKS-прокси для анонимизации трафика.  
Настройка SSH-туннелей: `ssh -L <локальный_порт>:<удаленный_хост>:<удаленный_порт> user@remote_server` - Создание прямого туннеля, `ssh -R <удаленный_порт>:<локальный_хост>:<локальный_порт> user@remote_server` - Создание обратного туннеля, `ssh -D <локальный_порт> user@remote_server` - Создание динамического туннеля.  

[Скрипт](https://github.com/AnatolyKuzmin/Linux/blob/main/security-setup.sh), автоматизирующий настройку базовой безопасности сервера: обновление системы, настройка SSH (отключение парольной аутентификации, изменение порта), установка и настройка firewall (ufw или firewalld).<br>

## Автоматизация и скрипты

### Основы Bash scripting

Что такое Bash?<br>
это командная оболочка, используемая в Unix-подобных операционных системах, таких как Linux и macOS. Она была разработана как альтернатива оригинальной оболочке Bourne shell и является оболочкой по умолчанию в большинстве дистрибутивов Linux. Bash-скрипт — это текстовый файл, содержащий последовательность команд, которые выполняются интерпретатором Bash построчно.  

Переменные и типы данных.<br>
Типы переменных: **Переменные окружения (environment variables)** Это глобальные переменные, доступные во всех оболочках. Они обычно записываются заглавными буквами, например, $USER, $PATH. **Пользовательские переменные (user-defined variables)** Создаются пользователем и могут быть локальными или глобальными. Локальные переменные доступны только в текущей оболочке, а глобальные — во всех дочерних процессах после экспорта с помощью команды export.  Типы данных: Строки: По умолчанию переменные в Bash содержат строки. Если строка состоит только из цифр, Bash позволяет выполнять над ней арифметические операции. Числа: Хотя Bash не имеет отдельного типа для чисел, он поддерживает целочисленную арифметику с переменными, содержащими только цифры.  
`VAR="value"` Определение переменной, `export VAR="value"` Экспорт переменной, `unset VAR` Удаление переменной. $VAR или ${VAR} для доступа к значению переменной.  
Специальные переменные:  
- $0, $1, $2, ...: Параметры командной строки, переданные в скрипт.
- $#: Количество параметров командной строки.
- $@ и $*: Массивы всех параметров командной строки.
- $$: PID текущего процесса.
- $?: Код завершения последней команды.

Операторы и выражения.<br>
Операторы сравнения для числе: `-eq`	Равно	[ $a -eq $b ], `-ne`	Не равно	[ $a -ne $b ], `-lt`	Меньше	[ $a -lt $b ], `-le`	Меньше или равно	[ $a -le $b ], `-gt`	Больше	[ $a -gt $b ], `-ge`	Больше или равно	[ $a -ge $b ].  
Операторы сравнения для строк: `=`	Равно	[ "$str" = "Bash" ], `!=`	Не равно	[ "$str" != "Zsh" ], `-z`	Пустая строка	[ -z "$str" ], `-n`	Непустая строка	[ -n "$str" ]  
Логические операторы(Внутри [ ]): `-a`	Логическое И (AND)	[ $a -eq 5 -a $b -eq 3 ], `-o`	Логическое ИЛИ (OR)	[ $a -eq 5 -o $b -eq 3 ], `!`	Отрицание (NOT)	[ ! -f file.txt ]  
Логические операторы(Внутри [[ ]]): `&&`	Логическое И	[[ $a > 5 && $b < 3 ]], `!`	Отрицание	[[ ! -d dir ]]  
Файловые операторы: `-e`	Файл/каталог существует	[ -e "/path/file" ], `-f`	Это файл (не каталог)	[ -f "file.txt" ], `-d`	Это каталог	[ -d "/tmp" ], `-s`	Файл не пустой	[ -s "data.log" ], `-r`	Файл доступен для чтения	[ -r "file.txt" ], `-w`	Файл доступен для записи	[ -w "file.txt" ]  

Примеры выражений  
Условие с числами:  
```
if [ $num -gt 10 ]; then
  echo "Число больше 10"
elif (( num == 5 )); then  # Альтернативный синтаксис
  echo "Число равно 5"
else
  echo "Неизвестное значение"
fi
```
Комбинирование условий:  
```
if [[ -f "$file" && -r "$file" ]]; then
  echo "Файл существует и доступен для чтения"
fi
```
Арифметические операции:  
```
let "count += 5"             # Увеличить переменную на 5
result=$(( (10 + 3) * 2 ))   # result = 26
```

Условные операторы: if, then, else, elif, fi.<br>
```
if [ условие1 ]; then
  # Команды, если условие1 истинно
elif [ условие2 ]; then
  # Команды, если условие1 ложно, но условие2 истинно
else
  # Команды, если все условия ложны
fi
```
`[ ]`: Используется для простых условий. `[[ ]]`: Предлагает расширенные возможности, такие как поддержка логических операторов (&&, ||)  

[Cкрипт](https://github.com/AnatolyKuzmin/Linux/blob/main/greeting.sh), который выводит приветствие в зависимости от времени суток. `chmod +x greeting.sh` Сделайте его исполняемым, `./greeting.sh` Запустить скрипт, указав путь к лог-файлу<br>

### Циклы
Циклы: for, while, until.  
Пример for. Используется для перебора элементов списка или диапазона: 1. Перебор диапазона чисел, 2. Перебор файлов в каталоге
```
for i in {1..5}
do
    echo "Число: $i"
done
```
```
for file in *.txt
do
    echo "Файл: $file"
done
```
Пример while. Выполняет команды, пока условие истинно.
```
coun=1
while [ $count -le 5 ]
do
    echo "Счетчик: $count"
    ((count++))
done
```
Пример until. Выполняет команды, пока условие ложно.
```
num=1
until [ $num -gt 5 ]
do
    echo "Число: $num"
    ((num++))
done
```
**Прерывание и продолжение цикла**. `break` — завершает выполнение цикла. `continue` — переходит к следующей итерации.
```
for i in {1..10}
do
    if [ $i -eq 5 ]; them
        echo "Прерывание на $i"
        break
    fi
    if (( $i % 2 == 0 )); then
        continue
    fi
    echo "Нечетное число: $i"
done
```

Работа со списками и массивами.  
В Bash массив — это переменная, которая может содержать несколько значений, доступных по индексу.  
`my_array=(apple banana cherry)` # Объявление массива  
`my_array+=(orange)` # Добавление элементов  
`echo "${my_array[0]}"` # Доступ к элементам массива. Первый элемент  
`echo "${my_array[@]}"` # Доступ к элементам массива. Все элементы  
`echo "${#my_array[@]}"` # Доступ к элементам массива. Количество элементов  
`my_array[1]="grape"` # Изменение элемента  
`unset my_array[2]` # Удаление элемента  
Перебор элементов массива.  
```  
for fruit in "${my_array[@]}" # С помощью цикла for
do
  echo "Фрукт: $fruit"
done
```
```  
for i in "${!my_array[@]}" # По индексам
do
  echo "Индекс $i: ${my_array[$i]}"
done
```
В Bash список часто представлен как строка с разделителями.  
```
list="one two three"
for item in $list
do
  echo "Элемент: $item"
done
```
Ассоциативные массивы позволяют использовать строки в качестве индексов.  
```
declare -A capitals
capitals[Russia]="Moscow"
capitals[France]="Paris"
capitals[Germany]="Berlin"

echo "Столица Франции: ${capitals[France]}"
```

Функции.  
Функции в Bash — это именованные блоки кода, которые позволяют повторно использовать фрагменты скрипта, упрощая и структурируя код.  
Функции могут принимать аргументы, которые внутри функции доступны как позиционные параметры: `$0` — имя скрипта, `$1, $2, ...` — первый, второй и последующие аргументы, `$#` — количество аргументов.  
Команда **return** возвращает целочисленный код завершения (от 0 до 255), который доступен через `$?` после вызова функции. Для возврата строкового значения обычно используют вывод через `echo` и присваивание результата вызова функции переменной.  
Пример функции с обработкой аргументов и условие:
```
add_numbers() {
  if [ $# -eq 0 ]; then
    echo "Нет аргументов"
  elif [ $# -eq 1 ]; then
    echo $(( $1 + $1 ))
  else
    echo $(( $1 + $2 ))
  fi
}

echo "Сумма 10 и 15: $(add_numbers 10 15)"
echo "Удвоение 10: $(add_numbers 10)"
echo "Без аргументов: $(add_numbers)"
``` 
📌 Важные момент:
- Функции должны быть объявлены до их вызова.
- Имена функций должны быть уникальными, чтобы избежать перезаписи.
- Аргументы функции работают аналогично аргументам скрипта.
- Используйте local для объявления локальных переменных внутри функции, чтобы избежать конфликтов.

Аргументы командной строки.  
Аргументы командной строки — это параметры, которые передаются Bash-скрипту при его запуске. Они позволяют сделать скрипты интерактивными и универсальными, управляя их поведением без изменения кода.  
Основные переменные для аргументов:
- $0 — имя скрипта.
- $1, $2, ..., $9 — первый, второй и последующие аргументы.
- ${10}, ${11} и т.д. — аргументы с номерами больше 9 (требуют фигурных скобок).
- $# — количество переданных аргументов.
- $@ — все аргументы как отдельные слова.
- $* — все аргументы как одна строка.
Пример: файл `script.sh`
```
#!/bin/bash

echo "Имя скрипта: $0"
echo "Первый аргумент: $1"
echo "Второй аргумент: $2"
echo "Всего аргументов: $#"

echo "Все аргументы через \$@: $@"
echo "Все аргументы через \$*: $*"
```
Запуск: `./script.sh arg1 arg2 arg3`
Вывод:
```
Имя скрипта: ./script.sh
Первый аргумент: arg1
Второй аргумент: arg2
Всего аргументов: 3
Все аргументы через $@: arg1 arg2 arg3
Все аргументы через $*: arg1 arg2 arg3
```
Часто аргументы бывают ключами вида -a, -b и т.п. Их удобно обрабатывать с помощью конструкции case и цикла while.  
Пример: файл `script.sh`
```
#!/bin/bash

while [ -n "$1" ]; do
  case "$1" in
    -a) echo "Найден ключ -a" ;;
    -b) echo "Найден ключ -b" ;;
    -c) echo "Найден ключ -c" ;;
    *) echo "Неизвестный параметр: $1" ;;
  esac
  shift
done
```
Запуск: `./script.sh -a -b -d`
Вывод:
```
Найден ключ -a
Найден ключ -b
Неизвестный параметр: -d
```

Пример простого [Bash-скрипта](https://github.com/AnatolyKuzmin/Linux/blob/main/script_DIR.sh), который обрабатывает список файлов в заданном каталоге. Он перебирает все файлы в указанной директории и выполняет с ними действия (например, выводит имя файла и его размер). `chmod +x script_DIR.sh` Сделайте его исполняемым, `./script.sh /путь/к/каталогу` Запустить скрипт, указав путь<br>

### Работа с текстом в скриптах
grep, sed, awk в скриптах.  
grep — поиск по шаблону. Ищет строки, соответствующие заданному шаблону (регулярному выражению), в файлах или потоке данных.  
Примеры:  
- Поиск строки с "root" в файле /etc/passwd `grep root /etc/passwd`
- Поиск без учёта регистра `grep -i "user" users.txt`
- Рекурсивный поиск по каталогу `grep -r "swap" /etc`
- Исключить строки по шаблону `ps aux | grep bash | grep -v grep`
- Поиск только целых слов `grep -w login /etc/passwd`
- Показать номера строк `grep -w login /etc/passwd`
- Показать номера строк `grep -n "error" logfile.txt`

sed — потоковый редактор. Предназначен для автоматического редактирования текста. Он может заменять, удалять, вставлять строки и выполнять другие операции.  
Примеры:  
- Замена "apple" на "orange" во всех строках файла `sed 's/apple/orange/g' fruits.txt`
- Редактирование файла "на месте" `sed -i 's/old/new/g' file.txt`
- Удаление строк, содержащих "DEBUG", из лога `sed '/DEBUG/d' logfile.txt`
- Удаление номеров строк в начале строки `sed 's/^ *[0-9]* //g' filename`

awk — обработка и анализ текстовых данных. Язык для обработки и анализа текстовых файлов, особенно табличных данных.  
Примеры:  
- Вывести первую колонку файла /etc/passwd (имена пользователей) `awk -F':' '{ print $1 }' /etc/passwd`
- Вывести вторую и четвёртую колонку файла `awk '{ print $2, $4 }' data.txt`
- Пронумеровать строки `awk '{ print FNR ": " $0 }' file.txt`
- Фильтрация строк по шаблону `awk '/ERROR/ { print $0 }' logfile.txt`

📌 Эти инструменты часто используют вместе для сложной обработки данных.  
- Найти строки с "error", заменить "error" на "warning", вывести дату и сообщение `grep "error" logfile.txt | sed 's/error/warning/g' | awk '{print $1, $2, $3, $4, $5}'`
- Извлечь IP-адреса, заменить точки на дефисы, красиво оформить вывод `grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" access.log | sed 's/\./-/g' | awk '{print "IP Address: " $1}`

Регулярные выражения - это последовательность символов, которая описывает шаблон для поиска в тексте. С помощью регулярных выражений можно находить слова, числа, проверять формат данных и многое другое.  
Якоря `^` - начало строки, `$` - конец строки.  
Классы символов: позволяют задавать диапазоны или наборы символов.
- `[abc]` - любой из символов a, b или c
- `[0-9]` - любая цифра от 0 до 9
- `[^abc]` - любой символ, кроме a, b или c (отрицание)
- `\d` - любая цифра (эквивалент [0-9])
- `\w` - буква, цифра или подчёркивание
- `\s` - пробельный символ  
Пример: `[а-яёА-ЯЁ]` - любая буква кириллицы в любом регистре
Квантификаторы: задают количество повторений символа или группы.  
- `*` - 0 и более раз
- `+` - 1 и более раз
- `?` - 0 или 1 раз
- `{n}` - ровно n раз
- `{n,}` - n и более раз
- `{n,m}` - от n до m раз

**Пример составления регулярного выражения**  
Если нужно проверить логин, который должен содержать буквы (латиница и кириллица) и цифры, быть длиной не менее трёх символов, и регистр не важен
`/^[a-zа-яё0-9]{3,}$/i`. `^` и `$` - ограничивают поиск всей строкой, `[a-zа-яё0-9]` - допустимые символы, `{3,}` - минимум 3 символа, `i` - флаг игнорирования регистра.  

Обработка вывода команд.  

**Стандартные потоки ввода-вывода**  
STDOUT (стандартный вывод) - поток, в который команда выводит результат своей работы (обычно это экран терминала).  
STDERR (стандартный поток ошибок) - поток для сообщений об ошибках.  
STDIN (стандартный ввод) - поток, из которого команда читает данные (обычно клавиатура).  
Перенаправление стандартного вывода в файл `команда > файл       # перезаписать файл`, `команда >> файл      # добавить в конец файла`.  
`ls ~ > /tmp/home.txt`  
Перенаправление ошибок `команда 2> errors.log    # ошибки в файл`, `команда 2>> errors.log   # добавить ошибки в файл`.  
Перенаправление и stdout, и stderr в один файл `команда > all_output.log 2>&1`.  

Конвейеры (пайпы) - Позволяют передавать вывод одной команды на вход другой с помощью символа `|`.  
`history | grep ls | less` - Здесь вывод команды history передаётся в grep, который фильтрует строки с ls, а затем результат показывается постранично через less.  
Команда `tee` - Позволяет одновременно выводить данные на экран и записывать их в файл. `команда | tee файл.txt`  
Пример использования в скрипте.  
```
#!/bin/bash

# Перенаправление всего вывода в файл
exec > output.log 2>&1

echo "Начинаем выполнение скрипта"

ls /nonexistent_dir    # эта команда вызовет ошибку, которая попадёт в output.log

echo "Скрипт завершён"
```

Чтение и запись в файлы.  
- cat - выводит содержимое файла целиком `cat filename.txt`
- head - выводит первые N строк файла (по умолчанию 10) `head -n 5 filename.txt`
- tail - выводит последние N строк файла (по умолчанию 10) `tail -n 5 filename.txt`
- tail -f - выводит последние строки и продолжает следить за добавлением новых (полезно для логов) `tail -f /var/log/syslog`
- less и more - постраничный просмотр больших файлов с возможностью прокрутки и поиска `less filename.txt`
  - q - выход, /текст - поиск, n - следующий результат поиск
- Перезапись файла `echo "Текст" > filename.txt`
- Добавление в конец файла `echo "Новая строка" >> filename.txt`
- Ввод текста с клавиатуры и запись в файл (для завершения нажмите Ctrl+D) `cat > filename.txt`
- Добавление текста в конец файла `cat >> filename.txt`

Пример [Bash-скрипта](https://github.com/AnatolyKuzmin/Linux/blob/main/extract_log.sh), который извлекает определённую информацию из лог-файла по заданному шаблону и записывает результат в другой файл. `chmod +x extract_log.sh` Сделайте его исполняемым, `./extract_log.sh /var/log/syslog "error|fail|critical" errors.txt` Пример запуска. <br>

### Cron

Cron - это системный планировщик задач в Linux и Unix-подобных системах, который позволяет автоматически запускать команды или скрипты в заданное время или с определённой периодичностью. Он работает в фоновом режиме и исполняет задачи по расписанию. Демон cron - сервис, который постоянно работает в системе и следит за расписаниями. Crontab - файл или набор файлов с расписаниями задач. Каждая запись определяет, когда и какую команду выполнять.  
В полях можно использовать: * - любое значение; Списки через запятую, например 1,15,30; Диапазоны через дефис, например 1-5; Шаги через /, например */10 - каждые 10 минут.  
Управление crontab:
- `crontab -e` - редактирование расписания текущего пользователя.
- `crontab -l` - просмотр текущих заданий.
- `crontab -r` - удаление всех заданий пользователя.
- `crontab -u user -e` - редактирование расписания другого пользователя (требуются права root).

Примеры расписаний. Каждая строка в crontab состоит из 6 полей: **minute hour day month weekday command**  
`0 9,18 * * 1 /home/ivan/script.sh` - Запуск скрипта каждый понедельник в 9:00 и 18:00:  
`30 */12 * * * /home/ivan/script.sh` - Запуск скрипта каждый день в 0:30 и 12:30:  
`0 12 1 * * /home/ivan/command` - Запуск команды 1-го числа каждого месяца в 12:00:  
`0 0 * * 1-5 /home/ivan/script.sh` - Запуск скрипта в полночь с понедельника по пятницу:  
`02 04 5 * * /usr/local/bin/bckp -vbd1 ; /usr/local/bin/bckp -vbd2` - Резервное копирование на два разных диска.  

Системный crontab и пользовательский crontab.  
**Пользовательский crontab** позволяет каждому пользователю создавать собственное расписание задач, которые будут выполняться от имени этого пользователя. Для каждого пользователя отдельный файл в каталоге /var/spool/cron/crontabs/, например, /var/spool/cron/crontabs/john для пользователя john. Редактирование напрямую файла запрещено - только через утилиту crontab.  
**Системный crontab** используется для планирования задач, важных для всей системы, или для запуска задач от имени разных пользователей. Основной файл: /etc/crontab. Дополнительно: отдельные задания могут располагаться в /etc/cron.d/ (каждое задание - отдельный файл). Редактируется вручную с помощью текстового редактора (например, nano /etc/crontab).  

#### [Скрипт](https://github.com/AnatolyKuzmin/Linux/blob/main/backup_script.sh), автоматизирующий резервное копирование важных данных (например, домашние каталоги пользователей, базы данных, конфигурационные файлы) с возможностью выбора места хранения резервных копий (локальный диск, удаленный сервер) и ротации старых копий.
- Добавьте запуск скрипта в cron для автоматизации `0 3 * * * /path/to/backup_script.sh >> /var/log/backup.log 2>&1`
- Для резервного копирования баз данных настройте функцию backup_database с вашими параметрами.

### Виртуализация (KVM/QEMU)

Что такое виртуализация? Типы виртуализации.  
Виртуализация - это технология, позволяющая создавать изолированные программные или аппаратные среды (виртуальные машины, контейнеры и др.) на одном физическом устройстве. Проще говоря, виртуализация позволяет запускать несколько независимых операционных систем или приложений на одном сервере или компьютере, эффективно распределяя ресурсы между ними. Каждый виртуальный экземпляр работает так, будто у него есть собственные процессор, память, дисковое пространство и сеть, хотя на самом деле все они используют общий физический ресурс.  
Типы виртуализации:
- Аппаратная виртуализация (Hardware Virtualization). Основана на использовании гипервизора, который напрямую управляет аппаратными ресурсами и разделяет их между виртуальными машинами. Каждая виртуальная машина (ВМ) может запускать собственную операционную систему с отдельным ядром. Примеры: VMware ESXi, KVM, Xen, Hyper-V. Отличается высокой производительностью и изоляцией.
- Программная виртуализация (Software Virtualization). Деление ресурсов происходит за счет программного слоя, обычно на уровне операционной системы. Все виртуальные среды используют общее ядро хостовой ОС. Производительность ниже, чем у аппаратной виртуализации. Применяется для менее ресурсоемких задач.
- Контейнерная виртуализация (Virtualization at OS Level). Виртуализация на уровне операционной системы: создаются изолированные контейнеры, которые используют общее ядро, но работают как отдельные среды. Примеры: Docker, LXC, OpenVZ. Позволяет быстро создавать и запускать изолированные приложения, но все контейнеры должны быть на одной ОС.
- Виртуализация приложений (Application Virtualization). Изоляция и запуск отдельных приложений в виртуальной среде, отделённой от основной ОС. Примеры: Citrix XenApp, Microsoft App-V.
- Виртуализация данных и хранилищ (Data/Storage Virtualization). Объединяет различные физические устройства хранения данных в единый логический пул, упрощая управление и повышая эффективность.
- Виртуализация рабочих столов (Desktop Virtualization). Позволяет централизованно развернуть и управлять рабочими столами пользователей, которые запускаются на сервере, а доступ к ним осуществляется по сети (VDI, RDS).

Установка и настройка KVM/QEMU.  
KVM (Kernel-based Virtual Machine) и QEMU - это современные инструменты для аппаратной виртуализации в Linux. Они позволяют создавать и управлять виртуальными машинами с высокой производительностью и гибкими настройками.  
Перед установкой убедитесь, что ваш процессор поддерживает аппаратную виртуализацию (Intel VT-x/VT-d или AMD-V): `egrep -c '(vmx|svm)' /proc/cpuinfo`. Если результат больше 0 - поддержка есть. Установка необходимых пакетов
```
sudo apt update
sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager -y
```
- qemu-kvm - основной гипервизор,
- libvirt-* - сервисы управления виртуализацией,
- bridge-utils - для настройки сетевых мостов,
- virtinst, virt-manager - для удобного создания и управления ВМ (CLI и GUI)
Настройка пользователя. Добавьте пользователя в группы libvirt и kvm, чтобы разрешить управление виртуальными машинами без root:
```
sudo usermod -aG libvirt $USER
sudo usermod -aG kvm $USER
```
Перезайдите в систему или выполните newgrp libvirt и newgrp kvm для применения изменений.  
Активируйте и проверьте статус службы libvirtd. Статус должен быть active (running):
```
sudo systemctl enable --now libvirtd
sudo systemctl status libvirtd
```
Проверьте, что KVM работает. `lsmod | grep kvm` Должны быть загружены модули kvm_intel или kvm_amd (в зависимости от процессора). Проверьте наличие сетевого моста (обычно virbr0) `brctl show`  

Создание и управление виртуальными машинами.  
1. Создание ВМ.  
Через терминал  
```
virt-install \
  --name=ubuntu-vm \
  --ram=2048 \
  --vcpus=2 \
  --disk path=/var/lib/libvirt/images/ubuntu.qcow2,size=20 \
  --cdrom /path/to/ubuntu.iso \
  --network bridge=virbr0 \
  --graphics vnc
```
- --disk: путь к образу диска и его размер (в ГБ)
- --cdrom: путь к ISO-образу ОС
- --network: сетевой интерфейс (по умолчанию virbr0 с NAT)  
Через графический интерфейс (GUI)  
- Запустите virt-manager или панель Cockpit (cockpit-machines).  
- Нажмите Создать виртуальную машину → выберите ISO-образ → укажите параметры (память, CPU, диск).  
2. Управление ВМ  
`virsh list --all` - Просмотр списка ВМ. `virsh start ubuntu-vm` `virsh shutdown ubuntu-vm` `virsh destroy ubuntu-vm  # аварийное завершение` - Запуск/остановка. `virsh undefine ubuntu-vm` - Удаление ВМ. `virsh edit ubuntu-vm` - Редактирование конфигурации.
3. Настройка сети  
- Стандартный мост (NAT): автоматически создаётся как virbr0. Подходит для доступа ВМ в интернет.
- Ручной мост: для прямого доступа ВМ в локальную сеть. Пример настройки в /etc/netplan/ (Ubuntu):
```
network:
  version: 2
  bridges:
    br0:
      interfaces: [enp3s0]
      dhcp4: true
```
4. Работа с дисками
- Создание образа диска: `qemu-img create -f qcow2 /var/lib/libvirt/images/disk2.qcow2 30G`
  - -f qcow2 - формат образа (наиболее популярен qcow2, также часто используется raw)
- Добавление диска к существующей ВМ через virt-manager или редактирование XML-конфигурации.  

Работа с образами дисков.  
- Чтобы узнать подробности об образе `qemu-img info /path/to/disk.img`
- Проверить диск на наличие ошибок `qemu-img check /path/to/disk.img`
- Конвертация форматов образов `qemu-img convert -f qcow2 -O raw source.qcow2 dest.raw`
  - -f - исходный формат, -O - целевой формат
- Cоздания и управления снимками (сохранённых состояний)
```
qemu-img snapshot -c snapshot_name /path/to/disk.img   # создать снимок
qemu-img snapshot -l /path/to/disk.img                 # список снимков
qemu-img snapshot -a snapshot_name /path/to/disk.img   # откатиться к снимку
```
- Пример создания и подключения нового диска
```
# Создать диск
qemu-img create -f raw /var/lib/libvirt/images/data-disk.img 10G

# Подключить диск к ВМ (пример для KVM)
virsh attach-disk vm_name /var/lib/libvirt/images/data-disk.img vdb --persistent
```

### Docker (основы)

Что такое Docker? Контейнеры vs. Виртуальные машины.  
**Docker** - это открытая платформа с открытым исходным кодом для автоматизации разработки, доставки и развертывания приложений в изолированных контейнерах. Основная задача Docker - упростить создание стандартного и предсказуемого окружения, в котором приложение и все его зависимости упакованы в контейнер. Это позволяет запускать приложения одинаково как на локальной машине разработчика, так и на сервере в облаке или дата-центре.  
Контейнеры в Docker обеспечивают изоляцию процессов, что помогает избежать конфликтов между версиями библиотек или сервисов. Они запускаются очень быстро, потребляют мало ресурсов и легко масштабируются. Docker активно используется в DevOps, микросервисной архитектуре и управлении инфраструктурой, ускоряя цикл разработки и внедрения изменений.  
| Характеристика | Контейнеры (Docker) | Виртуальные машины (VM) |
|----|----|----|
| Архитектура | Используют ядро хост-ОС, изолируют приложения и их зависимости на уровне ОС | Эмулируют аппаратное обеспечение, каждое ВМ - своя ОС |
| Изоляция | Изолируют процессы, но используют общее ядро ОС |  общее ядро ОС	Полная изоляция, отдельное ядро и ОС для каждой ВМ |
| Ресурсы | Меньше накладных расходов, выше плотность размещения, быстрый запуск | Требуют больше ресурсов (CPU, RAM, диск), запуск медленнее |
| Портативность | Высокая: контейнер можно запустить на любой системе с Docker | Переносимость зависит от гипервизора и формата образа |
| Безопасность | Изоляция на уровне процессов, уязвимости ядра ОС могут затронуть все контейнеры | Изоляция на уровне ОС, уязвимости одной ВМ не влияют на другие |
| Постоянное хранилище | Требует специальных инструментов (volumes) для сохранения данных после удаления контейнера | Каждый ВМ имеет свой виртуальный диск |
| Масштабируемость | Легко и быстро масштабируются, подходят для микросервисов и краткоживущих задач | Масштабируются медленнее, подходят для долгоживущих сервисов |
| Обновления | Контейнеры пересобираются и разворачиваются заново | ВМ обновляются традиционными способами |

**Ключевые отличия:** Контейнеры запускаются быстрее, занимают меньше ресурсов и используют общее ядро ОС, что делает их идеальными для микросервисов, CI/CD и быстрого масштабирования. Виртуальные машины обеспечивают более высокий уровень изоляции, так как каждая ВМ работает на собственной ОС, но требуют больше ресурсов и запускаются медленнее.

Установка Docker(Ubuntu).  
`sudo apt update` - Обновите пакеты. `sudo apt install apt-transport-https ca-certificates curl software-properties-common` - Установите необходимые пакеты. `curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -` - Добавьте GPG-ключ репозитория Docker. `sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"` - Добавьте официальный репозиторий Docker. `sudo apt update` - Обновите пакеты снова. `sudo apt install docker-ce` - Установите Docker. `sudo systemctl status docker` - Проверьте статус Docker. `sudo docker run hello-world` Проверьте работу Docker.  

Работа с образами Docker.  
Образы Docker - это шаблоны, на основе которых создаются контейнеры. Они содержат все необходимые зависимости, библиотеки и настройки для запуска приложений. Работа с образами включает их создание, просмотр, загрузку, удаление и отправку в удалённые репозитории.  
Основные команды для работы с образами Docker  
`docker image build -t имя_репозитория/имя_образа:тег путь_к_Dockerfile` - Создание образа из Dockerfile(-t задаёт имя и тег образа, а точка . указывает на текущую директорию с Dockerfile). `docker images` - Просмотр локальных образов. `docker image inspect имя_образа` - Получение подробной информации об образе. `docker image history имя_образа` - Просмотр истории слоёв образа. `docker image rm имя_образа` - Удаление образа.  
`docker pull имя_образа` - Загрузка образа из удалённого репозитория (например, Docker Hub). `docker login` - Перед отправкой необходимо войти в Docker Hub. `docker image push имя_репозитория/имя_образа:тег` - После успешной авторизации.  
Пример полного цикла работы с образом  
`docker build -t username/myapp:1.0 .` - Создаём образ из Dockerfile.  
`docker images` - Просматриваем созданный образ.  
`docker run -d -p 8080:80 username/myapp:1.0` - Запускаем контейнер из образа.  
`docker login`
`docker push username/myapp:1.0` - Отправляем образ в Docker Hub.  

Запуск и управление контейнерами.  
**Контейнер** - это изолированная среда, созданная на основе Docker-образа, в которой запускается приложение или сервис. Запуск контейнера `docker run [OPTIONS] IMAGE [COMMAND] [ARG...]`. **IMAGE** - имя образа (например, nginx, python:3.10, hello-world). **[OPTIONS]** - дополнительные параметры (режим работы, подключение томов, портов и др.). **[COMMAND] [ARG...]** - команда, которую контейнер должен выполнить (опционально).  
`docker run hello-world` - Запустить контейнер из образа hello-world.  
`docker run -it ubuntu:latest bash` - Запустить контейнер с доступом к терминалу.  
`docker run -d nginx` - Запустить контейнер в фоновом режиме (detached mode).  
`docker run --name mynginx -d nginx` - Запустить контейнер с именем.  
`docker run --rm alpine echo "Hello from Alpine"` - Автоматически удалить контейнер после завершения.  
| Команда | Описание |
|----|----|
| docker ps | Список запущенных контейнеров |
| docker ps -a | Список всех контейнеров (в т.ч. остановленных) |
| docker start <имя/ID> | Запустить ранее созданный контейнер |
| docker stop <имя/ID> | Остановить контейнер |
| docker restart <имя/ID> | Перезапустить контейнер |
| docker rm <имя/ID> | Удалить контейнер (только остановленный) |
| docker logs <имя/ID> | Посмотреть логи контейнера |
| docker inspect <имя/ID> | Детальная информация о контейнере |
| docker exec -it <имя/ID> bash | Выполнить команду внутри работающего контейнера (например, открыть bash) |

`docker run -d -p 8080:80 --name webserver nginx`  
- -p <host_port>:<container_port> - проброс портов (например, -p 8080:80)
- -v <host_path>:<container_path> - подключение тома (например, -v /data:/app/data)
- --env <VAR>=<value> - передача переменных окружения
`docker container prune` - Удалить все остановленные контейнеры. `docker rm $(docker ps -qa)` - Удалить все контейнеры. `docker logs <имя/ID>` - Логи контейнера. `docker inspect <имя/ID>` - Информация о контейнере.  

Запустить веб-сервер в Docker-контейнере.  
Пример для Nginx  
`docker pull nginx` - Скачайте официальный образ веб-сервера.  
`mkdir -p ~/mynginx/html`  
`echo "<h1>Привет из Nginx!</h1>" > ~/mynginx/html/index.html` - Создайте директорию для сайта и добавьте туда свой index.htm  
`docker run --name mynginx -v ~/mynginx/html:/usr/share/nginx/html:ro -p 8080:80 -d nginx` - Запустите контейнер с пробросом портов и монтированием каталога  
- --name mynginx - имя контейнера
- -v ~/mynginx/html:/usr/share/nginx/html:ro - монтируем локальный каталог с сайтами в контейнер (только для чтения)
- -p 8080:80 - пробрасываем порт 8080 хоста на порт 80 контейнера
- -d - запускаем в фоновом режиме
`http://localhost:8080` - Проверьте работу веб-сервера.  

Пример для Apache  
`docker pull httpd` - Скачайте официальный образ веб-сервера.  
`mkdir ~/my-apache-website`  
`echo "<!DOCTYPE html><html><body><h1>Hello from Apache!</h1></body></html>" > ~/my-apache-website/index.html` - Создайте директорию для сайта и добавьте туда свой index.html  
`docker run -dit --name my-apache-server -p 8080:80 -v ~/my-apache-website:/usr/local/apache2/htdocs/ httpd:latest` - Запустите контейнер с пробросом портов и монтированием каталога  
`http://localhost:8080` - Проверьте работу веб-сервера.  

### Сети в Docker

Сети Docker: bridge, host, none.  
1. Bridge (мост)
- Bridge - сетевой драйвер по умолчанию в Docker. При запуске Docker на хосте автоматически создаётся виртуальный сетевой мост (обычно docker0), к которому подключаются все контейнеры, если не указано иное.
- Каждый контейнер получает отдельный виртуальный интерфейс и IP-адрес из подсети моста (например, 172.17.0.0/16).
- Контейнеры, подключённые к одной bridge-сети, могут свободно общаться друг с другом, но изолированы от контейнеров в других сетях.
- Для доступа к сервисам внутри контейнера снаружи необходимо пробрасывать порты (-p 8080:80).
- Bridge-сеть обеспечивает базовую изоляцию и подходит для большинства сценариев, когда контейнеры должны взаимодействовать между собой на одном хосте, но быть изолированными от других контейнеров и внешней сети.
2. Host (хостовая сеть)
- В режиме host контейнер использует сетевой стек хоста напрямую, без какой-либо сетевой изоляции.
- Контейнер получает доступ ко всем сетевым интерфейсам и портам хоста, как если бы приложение запускалось непосредственно на хостовой системе.
- Нет необходимости пробрасывать порты - сервисы внутри контейнера доступны на тех же портах, что и на хосте.
- Используется для приложений, которым нужна максимальная производительность сети или требуется прямой доступ к сетевым интерфейсам хоста.
- Минус: отсутствие сетевой изоляции между контейнером и хостом, что может снизить безопасность.
3. None (без сети)
- В режиме none контейнер полностью изолирован от любых сетей.
- В контейнере не создаётся ни одного сетевого интерфейса, кроме loopback (lo).
- Контейнер не может ни отправлять, ни принимать сетевой трафик извне.
- Такой режим подходит для задач, где сеть не нужна вовсе, либо для ручной настройки сетевых интерфейсов.

Примеры запуска:  
`docker run --network bridge nginx`      # по умолчанию  
`docker run --network host nginx`  
`docker run --network none nginx`  

Создание пользовательских сетей.  
Зачем нужны пользовательские сети?  
- Изоляция: Контейнеры, подключённые к одной пользовательской сети, изолированы от других сетей и контейнеров по умолчанию.
- DNS-резолвинг: В пользовательских bridge-сетях контейнеры могут обращаться друг к другу по именам, а не только по IP-адресам.
- Гибкость: Можно создавать сети разных типов (bridge, overlay, macvlan и др.), настраивать подсети, шлюзы, диапазоны IP и пр..
- Динамика: Контейнеры можно подключать и отключать от пользовательских сетей "на лету".
Основные типы пользовательских сетей  
- Bridge (мост): для связи и изоляции контейнеров на одном хосте.
- Overlay: для связи контейнеров на разных хостах в кластере Docker Swarm.
- Macvlan: контейнеры получают IP из физической сети и видны как отдельные устройства.

**Создание пользовательской bridge-сети**  
`docker network create --driver bridge my_bridge_network`  
Можно задать параметры: подсеть, шлюз, диапазон IP `docker network create --driver=bridge --subnet=192.168.100.0/24 --gateway=192.168.100.1 mynet`  
Запуск контейнеров в пользовательской сети
```
docker run -d --name container1 --network my_bridge_network nginx
docker run -d --name container2 --network my_bridge_network busybox sleep 1000
```
Теперь container2 может обратиться к container1 по имени: `docker exec container2 ping -c 4 container1`

**Создание overlay-сети (для Docker Swarm)**  
`docker network create --driver overlay --subnet=10.11.0.0/16 my_overlay`  
Overlay-сети позволяют соединять контейнеры на разных хостах в кластере.  

**Создание macvlan-сети**  
```
docker network create -d macvlan \
  --subnet=192.168.1.0/24 \
  --gateway=192.168.1.1 \
  -o parent=eth0 my_macvlan_network
```
Контейнеры в такой сети получают IP из указанной подсети и видны в вашей физической сети.  

**Использование в Docker Compose**  
В файле docker-compose.yml можно определить пользовательскую сеть и подключить к ней сервисы:
```
version: '3.8'
services:
  web:
    image: nginx
    networks:
      - my_bridge_network
  app:
    image: myapp
    networks:
      - my_bridge_network
networks:
  my_bridge_network:
    driver: bridge
```
Запуск:  `docker compose up -d`. Оба сервиса будут в одной пользовательской сети и смогут обращаться друг к другу по имени.  
Преимущества пользовательских сетей  
- Автоматический DNS между контейнерами.
- Лучшая изоляция по сравнению с default bridge.
- Гибкая настройка параметров сети (подсети, шлюзы, диапазоны IP).
- Возможность подключения и отключения контейнеров без остановки.

Связывание контейнеров.  
Связывание контейнеров в Docker - это организация сетевого взаимодействия между контейнерами для обмена данными и совместной работы сервисов. Контейнеры могут быть связаны разными способами, наиболее современные и рекомендуемые - через пользовательские сети Docker.  
**Взаимодействие контейнеров в одной сети**  
По умолчанию Docker создает сеть типа bridge. Все контейнеры, подключённые к одной сети (например, bridge или пользовательской bridge-сети), могут "видеть" друг друга и взаимодействовать по внутренним IP-адресам или по именам контейнеров. Для доступа к сервису в другом контейнере достаточно использовать его имя как хост (например, db:5432 для подключения к базе данных из приложения).  
```
docker network create mynet
docker run -d --name db --network mynet postgres
docker run -d --name app --network mynet myapp
```
**Как работает связь**  
Docker реализует связь через виртуальные сетевые интерфейсы (veth-пары) и bridge, которые обеспечивают маршрутизацию пакетов между контейнерами. Для поиска контейнеров по имени используется встроенный DNS-сервер Docker и автоматическое обновление файла /etc/hosts внутри контейнеров. Приложения обычно получают параметры подключения (имя хоста, порт) через переменные окружения или конфигурационные файлы.  
**Механизм Docker links (устаревший способ)**  
Ранее для связи использовалась опция --link, которая пробрасывала переменные окружения и обновляла /etc/hosts. Сейчас рекомендуется использовать пользовательские сети, так как они более гибкие и удобные. Пример запуска:
```
docker run -d --name db postgres
docker run -d --name app --link db:db myapp
```
**Связь через Docker Compose**  
В Docker Compose сервисы по умолчанию попадают в одну сеть и могут обращаться друг к другу по именам сервисов. Внутри контейнера app база данных будет доступна по адресу db:5432. Пример (фрагмент docker-compose.yml):
```
services:
  db:
    image: postgres
  app:
    image: myapp
    depends_on:
      - db
```
**Альтернативные способы (socat, прокси)**  
Для нестандартных случаев можно использовать утилиты типа socat для проброса портов или туннелей между контейнерами.

Docker Compose (основы).  
Docker Compose - инструмент для управления многоконтейнерными приложениями, позволяющий описывать, запускать и администрировать связанные сервисы (контейнеры) с помощью одного конфигурационного файла docker-compose.yml. Это значительно упрощает разработку, тестирование и развертывание сложных проектов, где требуется взаимодействие нескольких контейнеров (например, приложения + база данных).  
Ключевые понятия Docker Compose  
- Файл конфигурации: В корне проекта создаётся файл docker-compose.yml, в котором описываются все сервисы, их параметры, сети, тома и переменные окружения.
- Сервис: Логическая единица, описывающая контейнер (или группу одинаковых контейнеров), например, web, db, redis и т.д.
- Сеть и тома: Docker Compose позволяет автоматически создавать пользовательские сети и тома для обмена данными и изоляции сервисов.  
Пример простого docker-compose.yml
В этом примере определены два сервиса: web (Nginx) и redis (Redis). Контейнер с Nginx будет доступен на порту 80 хоста.
```
version: '3'
services:
  web:
    image: nginx
    ports:
      - "80:80"
  redis:
    image: redis
```
Расширенный пример с зависимостями и томами. `depends_on` гарантирует, что база данных будет запущена раньше приложения. `volumes` обеспечивает сохранение данных базы вне контейнера. `healthcheck` позволяет следить за готовностью сервиса.
```
version: "3"
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    command: make start
    ports:
      - "3000:8000"
    volumes:
      - .:/app
      - /tmp:/tmp
    depends_on:
      - db
  db:
    image: postgres:latest
    environment:
      POSTGRES_PASSWORD: password
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
volumes:
  pgdata:
```
Основные команды Docker Compose  
| Команда | Описание |
| --- | --- |
| docker compose build | Сборка образов сервисов по описанию в файле |
| docker compose up | Запуск всех сервисов |
| docker compose up -d | Запуск в фоновом режиме |
| docker compose stop | Остановка сервисов (без удаления) |
| docker compose down | Остановка и удаление контейнеров, сетей, томов |
| docker compose logs <service> | Просмотр логов конкретного сервиса |
| docker compose exec <svc> sh | Выполнение команды внутри работающего контейнера |
| docker compose ps | Список всех сервисов и их статусов |

Особенности и преимущества
Автоматизация: Одна команда запускает все сервисы проекта. Изоляция: Каждый сервис работает в своём контейнере, но может общаться с другими по имени сервиса. Гибкость: Легко добавлять новые сервисы, тома, переменные окружения, пробрасывать порты, настраивать сети и ограничения ресурсов. Масштабируемость: Можно указать количество экземпляров сервиса (реплик) для тестирования нагрузки.

Создать сеть Docker и связать два контейнера (например, веб-сервер и базу данных).  
1. Создание пользовательской сети.
```
docker network create my_app_net
```
2. Запуск контейнера с базой данных (PostgreSQL)
```
docker run -d \
  --name db \
  --network my_app_net \
  -e POSTGRES_PASSWORD=mysecretpassword \
  postgres:latest
```
3. Запуск контейнера с веб-сервером (Nginx)
```
docker run -d \
  --name web \
  --network my_app_net \
  -p 80:80 \
  nginx:latest
```
4. Проверка связи между контейнерами  
Подключитесь к контейнеру web и проверьте доступность db по имени:
```
docker exec -it web ping db
```
Если ping отсутствует в образе, используйте временный контейнер для теста:
```
docker run --rm --network my_app_net busybox ping db
```
5. Пример настройки приложения для подключения к базе  
Если веб-сервер — это ваше приложение (например, Python/Node.js), укажите в его конфигурации:
```
DB_HOST=db
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=mysecretpassword
```
Итоговая схема  

| Хост-машина |
| ------------------ |
| Сеть: my_app_net |
|   - db (PostgreSQL) |
|   - web (Nginx) |
| |

Проверка сети и контейнеров  
- Просмотр списка сетей: `docker network ls`
- Детали сети: `docker network inspect my_app_net`  
Удаление сети и контейнеров
```
docker stop web db && docker rm web db
docker network rm my_app_net
```

### Ansible (основы)

Что такое Ansible? Infrastructure as Code.

-это инструмент с открытым исходным кодом для автоматизации управления IT-инфраструктурой, серверными конфигурациями, развертывания приложений, оркестрации сервисов и выполнения рутинных задач на множестве серверов одновременно.

Ключевые особенности Ansible:  
1. Безагентность: не требует установки дополнительного ПО (агентов) на управляемых серверах — достаточно SSH (для Linux/Unix) или WinRM (для Windows).
2. Идемпотентность: повторный запуск сценариев не приводит к нежелательным изменениям, если система уже находится в нужном состоянии.
3. Простота: сценарии (playbooks) пишутся на человекочитаемом языке YAML, что облегчает их создание и поддержку.
4. Модули: Ansible использует сотни встроенных модулей для типовых задач: установка ПО, копирование файлов, управление сервисами, настройка безопасности и др..
5. Кроссплатформенность: управляющий узел может работать на Linux, macOS, Windows и в облаке.
6. Интеграция: поддерживает работу с облачными провайдерами (AWS, Azure, Google Cloud), контейнерами (Docker, Kubernetes) и DevOps-инструментами.

Для чего используется Ansible:
- Управление конфигурациями серверов и поддержание их в согласованном состоянии.
- Автоматизация развертывания приложений и инфраструктуры.
- Оркестрация сложных операций между несколькими системами.
- Управление облачными ресурсами и контейнерами.
- Автоматизация задач безопасности, мониторинга, резервного копирования и восстановления.

**Infrastructure as Code (IaC)** — это подход к управлению и автоматизации инфраструктуры, при котором все настройки, развертывания и изменения описываются в виде кода (конфигурационных файлов). Такой подход позволяет хранить и версионировать инфраструктуру в системах контроля версий (например, Git). 
Автоматизировать создание, изменение и удаление серверов, сетей, облачных ресурсов и сервисов. Повысить воспроизводимость, надёжность и скорость развертывания инфраструктуры. Упростить совместную работу и аудит изменений.

Пример простого playbook Ansible (YAML)
```
- hosts: webservers
  become: yes
  tasks:
    - name: Установить nginx
      apt:
        name: nginx
        state: present
```

### Firewalld/iptables

Что такое firewall? Firewall (файервол, брандмауэр, межсетевой экран) — это система защиты, предназначенная для контроля и фильтрации сетевого трафика между компьютером или локальной сетью и внешними сетями (например, интернетом). Файервол может быть реализован как программное обеспечение, аппаратное устройство или их комбинация.  
Основные функции firewall:
- Фильтрация трафика: Анализирует входящие, исходящие и внутренние сетевые пакеты, пропуская только разрешённые соединения и блокируя подозрительные или запрещённые.
- Защита от атак: Предотвращает несанкционированный доступ, хакерские атаки, распространение вредоносных программ и утечку данных.
- Контроль доступа: Управляет разрешениями для различных пользователей и сервисов, определяя, какие соединения допустимы.
- Ведение журналов: Многие файерволы регистрируют события и попытки доступа для последующего анализа и аудита.

Файервол действует как "шлюз" или "охранник" на границе между сетями. Он анализирует каждый сетевой пакет по заранее заданным правилам: например, разрешить или запретить определённые IP-адреса, порты, протоколы или типы трафика. Решения о пропуске или блокировке пакетов принимаются на основе этих правил, которые обычно настраивает системный администратор.

Виды файерволов
- Программные: Устанавливаются на компьютеры и серверы для индивидуальной защиты (например, встроенный брандмауэр Windows).
- Аппаратные: Отдельные устройства, размещаемые между сетями, часто используются в корпоративных и промышленных сетях.
- Комбинированные: Совмещают программные и аппаратные компоненты для комплексной защиты.

Зачем нужен firewall? Защищает от несанкционированного доступа и атак извне. Блокирует вредоносный и нежелательный трафик. Сохраняет конфиденциальность данных и предотвращает утечки информации. Позволяет управлять доступом к ресурсам сети.

Firewalld: зоны, сервисы, правила.  

1. Зоны.
2. Сервисы.
3. Правила.

Если сервис не предопределён, порты можно открыть вручную:
```
# Открыть порт 3306/TCP для MySQL
firewall-cmd --zone=internal --add-port=3306/tcp --permanent

# Закрыть порт
firewall-cmd --zone=internal --remove-port=3306/tcp --permanent

# Просмотр открытых портов
firewall-cmd --zone=internal --list-ports
```
Основные команды  
`firewall-cmd --reload` - Применить изменения без перезагрузки.  
`firewall-cmd --list-all-zones` - Показать все зоны и их правила.  
`firewall-cmd --get-default-zone` - Текущая зона по умолчанию.  
`firewall-cmd --set-default-zone=home` - Изменить зону по умолчанию.  
`firewall-cmd --runtime-to-permanent` - 	Сохранить временные правила навсегда.

📌 Рекомендации по безопасности:
- Используйте минимальные необходимые разрешения.
- Для публичных серверов применяйте зоны public или dmz.
- Регулярно проверяйте активные правила: firewall-cmd --list-all.
- Избегайте зоны trusted для интернет-ориентированных интерфейсов.
- Для кастомных сервисов создавайте XML-файлы в /etc/firewalld/services/.

Пример создания сервиса:  
Создайте файл /etc/firewalld/services/myapp.xml
```
<?xml version="1.0" encoding="utf-8"?>
<service>
  <short>MyApp</short>
  <description>Custom application service</description>
  <port protocol="tcp" port="5000"/>
</service>
```
Обновите конфигурацию  
```
firewall-cmd --reload
firewall-cmd --add-service=myapp --permanent
```

Iptables: синтаксис и правила.
Примеры настройки firewall.
Настроить firewall для защиты веб-сервера.
### SELinux/AppArmor
Что такое SELinux/AppArmor?
SELinux: режимы работы, контексты.
AppArmor: профили.
Устранение проблем, связанных с SELinux/AppArmor.
Исследовать политики SELinux/AppArmor для веб-сервера.
### Мониторинг (Nagios/Zabbix)
Что такое мониторинг?
Nagios/Zabbix: установка и настройка (основы).
Настройка мониторинга основных параметров системы.
Уведомления о проблемах.
Настроить мониторинг загрузки процессора и использования диска.
### Базы данных (MySQL/PostgreSQL)
Что такое реляционные базы данных?
Установка и настройка MySQL/PostgreSQL.
Основные операции с базами данных: создание, удаление, резервное копирование.
Пользователи и права доступа в базах данных.
Создать базу данных и пользователя с ограниченными правами.
#### Настройка автоматического развертывания веб-приложения (например, WordPress) с использованием Docker Compose и Ansible. Включает в себя создание Dockerfile для веб-сервера и базы данных, написание Ansible playbook для развертывания приложения на удаленном сервере, настройку firewall и мониторинга.
## Углубленное изучение
### Более глубокое изучение выбранных тем (Docker, Ansible, K8s, Cloud)
### Решение реальных задач и разбор кейсов.
## Разработка комплексной системы мониторинга и управления инфраструктурой с использованием выбранных инструментов.
